# 정렬 Part1

> _데이터를 특정한 기준에 따라 순서대로 나열하는 것_

- 이진 탐색의 전처리 과정
- **✨코테, 면접 단골 출제 유형!✨**

<br>

## 선택 정렬

> _매번 가장 작은 값을 선택해서 앞으로 보내는 작업을 수행하는, 가장 원시적인 정렬 방법_

- 다른 정렬 알고리즘에 비해 매우 비효율적이지만, 코딩 테스트에서 선택 정렬 알고리즘을 사용할 일이 빈번히 등장하므로 익숙해질 필요가 있다.

<br>

### 수행 과정

① 데이터가 정렬되어 있지 않은 초기 데이터. 맨 앞의 값 7과 그 뒤의 값 중 가장 작은 값인 0을 맞바꾼다.

```
7 5 9 0 3 1 6 2 4 8
```

② 0과 7을 맞바꾼 뒤, 맨 앞을 제외하고 5부터 다시 비교 → 5와 1을 맞바꾼다.

```
0 5 9 7 3 1 6 2 4 8
```

③ 9부터 다시 비교 → 9와 2를 맞바꾼다.

```
0 1 9 7 3 5 6 2 4 8
```

④ 7부터 다시 비교 → 7과 3을 맞바꾼다.

```
0 1 2 7 3 5 6 9 4 8
```

⑤ 7부터 다시 비교 → 7와 4를 맞바꾼다.

```
0 1 2 3 7 5 6 9 4 8
```

⑥ … 위 과정을 반복해서 수행하다 보면 마지막 데이터는 이미 정렬된 상태로 완료된다.

```
0 1 2 3 4 5 6 7 8 9
```

<br>

### 소스코드

- 선택 정렬의 총 연산횟수는 `N+N-1+N-2+...+2`이므로 시간복잡도는 O(N^2)이다.
  - 이중 for문으로 구현하므로 시간복잡도가 O(N^2)임을 직관적으로 확인할 수 있다.
  - N 값이 커질수록 수행속도가 급격히 느려진다.
- 파이썬은 간단히 리스트 내 두 원소의 위치를 맞바꾸는 swap 작업이 가능하다.

```python
def selectionSort(array):
	for i in range(len(array)):
		min_index = i # 가장 작은 원소 인덱스값
		for j in range(i+1, len(array)):
			if array[min_index] > array[j]:
				min_array = j
		array[i], array[min_index] = array[min_index], array[i] # swap
```

---

## 삽입 정렬

> _특정 데이터를 적정 위치에 삽입하는 방식의 알고리즘으로, ‘**데이터가 거의 정렬되어 있을 때**’ 훨씬 효율적_

- **첫 번째 데이터는 정렬되어 있다고 간주**하여 그 다음 데이터부터 비교
- 정렬이 이루어진 원소는 항상 오름차순을 유지한다는 특징이 있다.

<br>

### 수행 과정

① 첫 번째 데이터 7은 정렬되어 있다고 간주! 그 다음 데이터 5는 7보다 작으므로 7의 왼쪽에 삽입한다.

```
7 5 9 0 3 1 6 2 4 8
```

② 다음 데이터 9는 다음 3가지 위치(`|`로 표기)에 삽입 가능하다. 5와 7보다 크므로 세 번째 위치에 삽입한다.

```
| 5 | 7 | 9 0 3 1 6 2 4 8
```

③ 다음 데이터 0은 5, 7, 9보다 작으므로 첫 번째 위치에 삽입한다.

```
| 5 | 7 | 9 | 0 3 1 6 2 4 8
```

④ 위 과정을 맨 마지막 데이터까지 반복하면 정렬이 완료된다.

```
0 1 2 3 4 5 6 7 8 9
```

<br>

### 소스 코드

- 선택 정렬과 같이 시간복잡도는 O(N^2)
- 그러나 데이터가 거의 정렬되어 있는 상태에선 삽입 정렬이 매우 빠르게 동작한다.
  - 최선의 경우는 O(N)의 시간복잡도를 갖는다.
  - **데이터가 거의 정렬되어 있다면 가장 효율적인 알고리즘!!**

```python
def insertionSort(array):
	for i in range(1, len(array)):
		for j in range(i, 0, -1):  # index i부터 1까지 감소하며 반복
			if array[j] < array[j-1]:
				array[j], array[j-1] = array[j-1], array[j]
			else:  # 자기보다 작은 데이터 만나면 stop
				break
```

---

## 퀵 정렬

> _기준이 되는 데이터, ‘피벗’을 설정하여 피벗보다 큰 값과 작은 값을 찾아 교환하는 방식의 알고리즘_

- 가장 많이 사용하는 알고리즘으로, 정렬 알고리즘의 근간이 되는 알고리즘이다.
- 삽입 정렬과 달리, **데이터가 무작위로 입력될수록** 속도가 빨라지고, 효율성이 높아진다!

<br>

### 수행 과정

**1️⃣ 첫 번째 프로세스**

① 첫 번째 데이터를 pivot으로 설정! 왼쪽에서부터 피벗보다 큰 값, 오른쪽에서부터 피벗보다 작은 값을 찾아 서로의 위치를 교환 → 7과 4의 위치를 교환한다.

```
5 7 9 0 3 1 6 2 4 8
5 4 9 0 3 1 6 2 7 8
```

② 그 다음 다시 피벗보다 큰 데이터와 작은 데이터를 찾아 위치를 교환 → 9와 2의 위치를 교환한다.

```
5 4 9 0 3 1 6 2 7 8
5 4 2 0 3 1 6 9 7 8
```

③ 그 다음도 똑같이 진행하면 6, 1이 선택되는데 두 값의 위치가 엇갈리게 된다. 그럴 땐 피벗과 작은 데이터를 교환 → 5와 1의 위치를 교환한다.

```
5 4 2 0 3 1 6 9 7 8
1 4 2 0 3 5 6 9 7 8
```

⇒ 그 결과, 피벗 왼쪽은 피벗보다 작은 값들, 오른쪽은 피벗보다 큰 값들이 존재한다.

2️⃣ **두 번째 프로세스** : 기존 피벗 기준 왼쪽과 오른쪽 리스트를 분할하여 정렬시킨다.

- 피벗보다 작은 값만 존재할 경우 → 그 다음 데이터를 피벗으로 지정
- 피벗보다 큰 값만 존재할 경우 → 그 중 가장 큰 값과 피벗 교환 후 그 값으로 피벗 지정

```
1 4 2 0 3 |5| 6 9 7 8
1 0 2 4 3 |5| 6 9 7 8
0 1 2 4 3 |5| 6 8 7 9
0 1 2 4 3 |5| 6 7 8 9
0 1 2 3 4 |5| 6 7 8 9
```

<br>

### 소스 코드

- 퀵 정렬의 평균 시간복잡도는 O(NlogN)으로 선택, 삽입 정렬에 비해 매우 빠르다.
- 최선의 경우 → 피벗 위치 변경 후 분할이 이루어질 때마다 절반씩 분할되는 경우
- 최악의 경우 → O(N^2), 삽입 정렬과 달리 데이터가 거의 정렬되어 있으면 속도가 느려진다.
  - **데이터가 무작위로 입력될수록 빠르게 동작할 확률이 높음!**

<br>

**⍢ 직관적 형태의 코드**

```python
array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

def quickSort(array, start, end):
	# 원소가 1개면 종료
	if start >= end:  return
	pivot = start
	left = start + 1; right = end

	while left <= right:
		# 피벗보다 큰 데이터 찾을 때까지 반복
		while left <= end and array[left] <= array[pivot]:  left += 1
		# 피벗보다 작은 데이터 찾을 때까지 반복
		while right > start and array[right] >= array[pivot]:  right -= 1

		# left, right 위치가 엇갈린 경우, 피벗과 작은 값(right) 교체
		if left > right:
			array[right], array[pivot] = array[pivot], array[right]
		else:
			array[left], array[right] = array[right], array[left]

	# 분할 후 왼쪽 리스트와 오른쪽 리스트 개별 정렬 수행
	quickSort(array, start, right-1)
	quickSort(array, right+1, end)

quickSort(array, 0, len(array)-1)
print(array)
```

**⍢ 파이썬의 장점을 살린 코드**

```python
array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

def quickSort(array):
	if len(array) <= 1: return array

	pivot = array[0]
	tail = array[1:]  # 피벗을 제외한 리스트

	left = [x for x in tail if x <= pivot]  # 피벗 기준 왼쪽 리스트
	right = [x for x in tail if x > pivot]  # 피벗 기준 오른쪽 리스트

	return quickSort(left) + [pivot] + quickSort(right)

print(quickSort(array))
```
