# Dynamic Programming

연산 속도와 메모리 공간을 최대한으로 활용하기 위한 효율적인 알고리즘이 필요하다.

어떤 문제는 메모리 공간을 약간 더 사용해서 연산 속도를 비약적으로 증가시키는 방법이 있는데 대표적인 방법이 바로 다이나믹 프로그래밍이다.

## DP 기본 컨셉

DP에는 **Top-down**, **Bottom-up**의 두 가지 유형이 있고, 그리고 자주 사용되는 **메모이제이션 기법**이 있다.

다음 두 조건을 만족할 때, DP를 적용하여 문제를 효율적으로 해결할 수 있다.

> ① 큰 문제를 작은 문제로 나눌 수 있다.
> ② 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

- 최적 부분 구조(Optimal Substructure) 문제는 DP 또는 그리디 알고리즘으로 해결 가능하다.

  **❓ 그리디 알고리즘과 DP가 뭐가 다르냐**

  ⇒ 그리디는 그 순간에 최적인 방법을 선택하면서 푸는 방식이고, DP는 **중복된 하위 문제**의 결과를 저장해가면서 푸는 방식이다.

- 최적 부분 구조 문제 중에서도 중복되지 않는 문제들은 분할-정복 알고리즘으로 분류된다.
  **❓분할 정복 알고리즘과 DP가 뭐가 다르냐**
  ⇒ 큰 문제를 작게 나누는 방식은 동일.
  그러나 다이나믹 프로그래밍은 문제들이 서로 영향을 미친다는 특징이 있다.
  (퀵 정렬) 피벗의 위치가 변경해서 자리잡으면 피벗은 바뀌지 않고, 그 피벗값을 다시 처리하는 과정이 없다.
  (DP) 한 번 해결했던 문제를 다시 해결 → 그러나 계산을 다시 하지 않고 호출하여 값을 불러온다.
  - 재귀 함수 특성상 오버헤드가 발생할 수 있으나, 반복문으로 대체하면 오버헤드를 줄일 수 있다.

| 알고리즘            | 문제 특징                          | 풀이 가능한 문제   |
| ------------------- | ---------------------------------- | ------------------ |
| 다이나믹 프로그래밍 | ⍥ 최적 부분 구조                   |
| ⍥ 중복된 하위 문제  | 피보나치 수열, 다익스트라 알고리즘 |
| 그리디 알고리즘     | ⍥ 최적 부분 구조                   |
| ⍥ 탐욕 선택 속성    | 다익스트라 알고리즘                |
| 분할-정복 알고리즘  | ⍥ 최적 부분 구조                   | 병합 정렬, 퀵 정렬 |

<br>

대표적인 문제가 피보나치 수열!

점화식을 적용한 재귀함수는 다음과 같다.

```python
def fibo(x):
	if x == 1 or x == 2:  return 1
	return fibo(x - 1) + fibo(x - 2)
```

⇒ 그러나 이 함수는 x값이 커질수록 수행시간이 기하급수적으로 늘어나는 치명적 단점이 존재한다.

동일 함수가 반복호출되고, 시간복잡도는 O(2^N)이 된다.
<br>

## 메모이제이션

> _한 번 구현한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법으로, 캐싱(Caching)이라고도 한다._

피보나치 수열을 메모이제이션 기법을 사용해서 해결하는 방법은, 재귀적으로 수행한 결과를 리스트에 저장하고, 같은 정보가 필요할 때 리스트에서 가져오는 것이다.

```python
# 메모이제이션을 위한 초기화
d = [0]*100

def fibo(x):
	if x == 1 or x == 2:  return 1
	# 계산한 적 있는 문제는 그대로 반환
	if d[x] != 0:
		return d[x]
	# 계산한 적 없는 문제는 점화식 적용
	d[x] = fibo(x - 1) + fibo(x - 2)
	return d[x]
```

⇒ 시간복잡도는 O(N)으로 성능과 효율이 올라간다.

- 메모이제이션은 탑다운 방식에 국한된 표현
  - 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미 → 다이나믹 프로그래밍에 활용되지 않을 수 있다.
- 수열은 배열이나 리스트로 표현되는데, 수열처럼 연속적이지 않은 경우에 사전 자료형이 유용하다.
  - collections 라이브러리의 `defaultdict()` 객체 사용 → 자료형 명시

<br>

### 방법1: Top-Down

> _큰 문제를 해결하기 위해 작은 문제를 호출하는 방식_

- ‘하향식’이라고도 하며, 특별히 *메모이제이션*이라 지칭한다.
- 재귀함수를 사용한 방식에 해당

### 방법2: Bottom-up

> _작은 문제부터 해결하여 답을 도출하는 방식_

- ‘상향식’, *Tabulation*이라고도 하며, 결과 저장용 리스트를 ‘DP 테이블’이라 부른다.
- 반복문을 사용한 방식에 해당

```python
d = [0]*100

d[1] = 1; d[2] = 1
n = 99

for i in range(3, n+1):
	d[i] = d[i - 1] + d[i - 2]
```

<br>

### DP 알고리즘으로 문제 접근하기

1. 코딩테스트에서의 DP 문제는 대체로 간단하니 기본 컨셉 정도만 제대로 이해해도 된다.
2. 주어진 문제가 DP 유형임을 파악하자.

   a. 완전 탐색 알고리즘으로 접근했을 때 시간이 오래걸린다? 해결 문제의 중복 여부를 파악하고 DP를 적용할 수 있는지 확인해보자.     
3. 우선 재귀함수로 작성하고, 메모이제이션을 적용할 수 있으면 이후에 코드를 개선하는 것도 좋은 방법이다.     
4. top-down 방식보다는 bottom-up 방식을 권장한다.

   a. 시스템상 재귀함수의 스택 크기가 한정되어 있을 수 있기 때문; `Recursion Depth` 오류     
   b. 아니면 sys 라이브러리의 `setrecursionlimit()` 함수로 재귀 제한을 완화하자.

---

🥕 **Reference**

- 파이썬 알고리즘 인터뷰
- 이것이 코딩 테스트다 with 파이썬
