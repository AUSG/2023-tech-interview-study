## ê°ì‹œ [15683ë²ˆ]

**Simulation**

[ê°ì‹œ](https://www.acmicpc.net/problem/15683)

### ì½”ë“œ
```java
// https://www.acmicpc.net/problem/15683
public class ê°ì‹œ {

   private static final int EMPTY = 0;
   private static final int WALL = 6;
   private static final int CHECK = 7;

   // ìœ„, ì˜¤ë¥¸ìª½, ì•„ë˜, ì™¼ìª½
   private static int[] dx = {-1, 0, 1, 0};
   private static int[] dy = {0, 1, 0, -1};

   private static int[][][] rotate = {
           {{0}},
           {{1}, {2}, {3}, {0}}, // 1
           {{1, 3}, {0, 2}},  // 2
           {{0, 1}, {1, 2}, {2, 3}, {3, 0}}, // 3
           {{0, 1, 3}, {0, 1, 2}, {1, 2, 3}, {2, 3, 0}}, // 4
           {{0, 1, 2, 3}} // 5
   };

   private static Cctv[] cctvs;
   private static int cctvCnt;
   private static int answer, N, M;

   public static void main(String[] args) throws IOException {
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
      StringTokenizer st = new StringTokenizer(br.readLine());

      N = Integer.parseInt(st.nextToken());
      M = Integer.parseInt(st.nextToken());

      int[][] map = new int[N][M];

      cctvs = new Cctv[8];

      answer = Integer.MAX_VALUE;
      int temp = N * M;

      for (int i = 0; i < N; i++) {
         st = new StringTokenizer(br.readLine());
         for (int j = 0; j < M; j++) {
            int number = Integer.parseInt(st.nextToken());

            map[i][j] = number;

            // CCTV
            if (number != EMPTY && number != WALL) {
               cctvs[cctvCnt++] = new Cctv(i, j, number);
            }
            else if(number == WALL) temp--;
         }
      }

      find(0, temp - cctvCnt, map);

      bw.write(String.valueOf(answer));
      bw.newLine();
      bw.flush();
      bw.close();
      br.close();
   }

   // cctvë¡œ ê°ì‹œí•  ì˜ì—­ ì°¾ê¸°
   private static void find(int cnt, int remain, int[][] map) {

      // ì‚¬ê°ì§€ëŒ€ ìµœì†Œ ê°’ìœ¼ë¡œ ê°±ì‹ 
      if(cnt == cctvCnt) {
         answer = Math.min(answer, remain);
         return;
      }

      int[][] newMap = new int[N][M];
      copyMap(newMap, map);

      Cctv cctv = cctvs[cnt];

      // 90ë„ íšŒì „
      for(int i = 0; i < rotate[cctv.number].length; i++) {
         int temp = 0;
         for(int j = 0; j < rotate[cctv.number][i].length; j++) {
            // ê°ì‹œí•  ë°©í–¥
            int dir = rotate[cctv.number][i][j];
            // ê°ì‹œí•  ìˆ˜ ìˆëŠ” ì˜ì—­ ìˆ˜ + ê°ì‹œí•œ ì˜ì—­ í‘œì‹œ
            temp += checkCount(cctv.x, cctv.y, dir, newMap);
         }
         // ë‹¤ìŒ cctvë¡œ ë„˜ì–´ê°
         find(cnt + 1, remain - temp, newMap);
         copyMap(newMap, map);
      }
   }

   // cctvì˜ ê° ë°©í–¥ìœ¼ë¡œ ê°ì‹œí•  ê³³ ì°¾ê¸°
   private static int checkCount(int x, int y, int dir, int[][] map) {

      int count = 0;

      while(true) {

         x += dx[dir];
         y += dy[dir];

         if(x < 0 || x >= N || y < 0 || y >= M) break;
         if(map[x][y] == WALL) break;
         if(map[x][y] == EMPTY) {
            count++;
            map[x][y] = CHECK;
         }
      }
      return count;
   }

   private static void copyMap(int[][] newMap, int[][] map) {
      for(int i = 0; i < N; i++) {
         for(int j = 0; j < M; j++) {
            newMap[i][j] = map[i][j];
         }
      }
   }


   private static class Cctv {
      int x, y, number;

      public Cctv(int x, int y, int number) {
         this.x = x;
         this.y = y;
         this.number = number;
      }
   }

}
```

### ğŸ“–Â í•´ê²°ë°©ë²•

`ì‹œë®¬ë ˆì´ì…˜`  

1. ê° CCTV ë²ˆí˜¸ë§ˆë‹¤ íšŒì „ì„ í•˜ëŠ” ê²½ìš°ë¥¼ ë¯¸ë¦¬ ì €ì¥(rotate ë°°ì—´)
2. CCTVì˜ ì •ë³´ë¥¼ ì €ì¥ (cctvs)
3. cctvì˜ ê°œìˆ˜ ë§Œí¼ ë°˜ë³µë¬¸ì„ ëŒë©´ì„œ ê° CCTVë¥¼ íšŒì „ì‹œí‚¤ë©´ì„œ ë‹¤ìŒ CCTVë¡œ ë„˜ì–´ê°
4. ëª¨ë“  CCTVë¥¼ í™•ì¸í–ˆì„ ë•Œ ìµœì†Œ ì‚¬ê°ì§€ëŒ€ì˜ ìˆ˜ë¥¼ ê°±ì‹ 
