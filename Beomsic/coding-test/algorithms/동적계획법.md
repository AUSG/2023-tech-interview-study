## 📌 동적 계획법

---

💡 **동적 계획법 (Dynamic Programming, DP)**

- 큰 의미에서 분할 정복과 같은 접근 방식을 의미한다.

동적 계획법을 사용하는 알고리즘 또한 처음 주어진 문제를 더 작은 문제들로 나눈 후 각 조각의 답을 계산하고, 이 답들을 이용해 원래 문제에 대한 답을 계산해낸다.


### 동적 계획법과 분할정복의 차이 ❓

**분할정복**

- 서로 연관 없는 부분문제로 분할
- 부분 문제를 재귀적으로 해결 → 결합

**동적 계획법**

- 부분 문제들이 연관이 없다면 사용할 수 없다.
- 부분 문제들은 더 작은 부분 문제들을 공유한다.(중복 사용)
- 모든 부분 문제들은 한번만 계산하고 결과를 저장해 재사용한다.

동적 계획법에서 부분 문제는 두 개 이상의 문제를 푸는데 사용될 수 있다.

따라서, 계산 결과를 재활용해 속도를 향상

- 그러기 위해서는 각 문제의 답을 메모리에 저장해 두어야 한다.

### 🧑‍💻 해결 방법

**Top Down**

- 큰 문제 → 작은 문제 로 해결
- 재귀 알고리즘을 사용
- 메모이제이션 기법

**Bottom Up**

- 반복문을 통해 가장 작은 문제에서 해결하는 문제에 도달할 때까지 반복

## ❗ 메모이제이션 (memoization)

**한 번 계산한 값을 저장해 두었다 재활용하는 최적화 기법**

메모이제이션을 사용하면 모든 부분 문제가 한 번씩만 계산된다고 보장된다.

- 두 번 이상 반복 계산되는 부분 문제들의 답을 미리 저장함

  ⇒ 속도가 향상!


### 예시

```java
// 메모이제이션 사용 예시
int[] cache = new int[N];

// cache 배열 초기화
for(int i = 0; i < N; i++) cache[i] = -1;

int memoizationFun(int a, ...) {
	
  // 기저 사례 처리
  if(...) then...
  
  // 이미 a에 대한 답을 구한적이 있다면 반환
  int ret = cache[a];
  if(ret != -1) return ret;

  // 계산
  ...
  return ret;
}
```

> **📖 메모이제이션 구현 시 고려사항**
>
>
>
> 1. **기저 사례**를 제일 먼저 처리
     >     - ex) 입력이 범위를 벗어난 경우 → 범위를 벗어나는 오류 방지
>
> 2. 함수의 반환 값을 생각하여 **cache 배열을 초기화**
     >     - ex) 항상 반환값이 0 이상인 경우 cache 배열의 element들을 `-1`로 초기화
>
> 3. ret이 cache[a]에 대한 **참조형**이란 것을 유의
     >     - ret의 값을 바꾸면 cache[a]의 값도 변한다.

**💡 TIP**

메모이제이션 배열을 초기화하는 것은 자주 일어난다.

따라서, 다중 for문 보다 쉽게 초기화할 수 있는 방법을 알아두면 좋다

### 시간 복잡도

```java
(존재하는 부분 문제의 수) X (한 부분 문제를 풀 때 필요한 반복문의 수행 횟수)
```

## 📌 최적화 문제들

---

동적계획법의 가장 일반적인 사용처 - `최적화 문제`

- 최적화 원칙을 만족해야만 효율적으로 적용할 수 있다.

### 최적화 문제❓ 최적화 원칙 ❓

<aside>
💡 **최적화 문제**

- 여러 개의 가능한 답 중 가장 좋은 답(최적해)를 찾는 문제

**최적화 원칙**

- 어떤 문제에 대한 답이 최적일 때 그 답을 구성하는 작은 문제들의 답 역시 최적이어야 한다.
</aside>

- 최적화 문제를 푸는 것은 완전탐색에서 시작
- 최적화 문제에 특정 성질이 성립할 경우 메모이제이션을 적용하기 보다 더 효율적으로 동적계획법을 구현할 수 있다.

> 📖 **최적화 문제 동적계획법 풀이방법**
>
> - 모든 답을 만들어보고 최적해의 점수를 반환하는 완전탐색 알고리즘을 설계해본다.
> - 전체 답의 점수를 반환하는 것이 아닌, 앞으로 남은 선택들에 해당하는 점수만 반환하도록 부분 문제 정의를 바꾼다.
> - 재귀호출의 입력에 이전 선택에 관련된 정보가 있다면 꼭 필요한 것만 남기고 줄인다.
    >     - 입력의 종류가 줄어들면 줄어들 수록 더 많은 부분 문제가 중복된다.
>     - 메모이제이션을 최대한으로 활용할 수 있다.

## 📖 최장 증가 부분 수열(LIS, Longest Increasing Subsequece)

---

> **최장 증가 부분 수열**
>
> - 원소가 n개인 배열의 일부 원소를 골라 만든 부분 배열 중
> - 각 원소가 이전 원소보다 크고
> - 배열의 길이가 최대인 부분 수열
>
> **예시**
>
> [ **5**, 10, **7**, 1, **8, 9, 11**, 3 ] 이라는 배열에서 LIS는 [ 5, 7, 8, 9, 11] 이다.
>

### LIS의 길이 구하기

***이중 for문 사용 (dp)***

```java
for(int i = 0; i < n; i++) {
	length[i] = 1;
	for(int j = 0; j < i; j++) {
		if(numbers[j] < numbers[i]) {
			length[i] = Math.max(length[i], length[j] + 1);
		}
	}
}
```

- **int[] length : i 번째 인덱스에서 끝나는 LIS의 길이**
- **int[] numbers  : 주어진 배열**

`시간 복잡도 - O(n^2)`

***이분탐색 이용***

LIS의 형태를 유지하기 위해 주어진 배열의 인덱스를 돌면서 숫자가 들어갈 위치를 이분탐색으로 탐색한다.