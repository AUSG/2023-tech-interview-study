## [í”„ë¡œê·¸ë˜ë¨¸ìŠ¤] ê°€ì¥ ë¨¼ ë…¸ë“œ

[ê°€ì¥ ë¨¼ ë…¸ë“œ](https://school.programmers.co.kr/learn/courses/30/lessons/49189)

### ì½”ë“œ

```java
import java.util.*;

class Solution {

  private static final int FIRST_START_NODE = 1;

  private static int distance;
  private static int answer;
  private List<Integer>[] node;

  public int solution(int n, int[][] edge) {

    node = new List[n + 1];
    for(int i = 1; i <= n; i++) {
      node[i] = new ArrayList<>();
    }

    for(int i = 0; i < edge.length; i++) {
      int node1 = edge[i][0];
      int node2 = edge[i][1];
      node[node1].add(node2);
      node[node2].add(node1);
    }

    bfs(n, FIRST_START_NODE);

    return answer;
  }

  private void bfs(int n, int start) {

    Queue<Node> nodeQueue = new LinkedList<>();
    boolean[] visited = new boolean[n + 1];
    visited[start] = true;
    nodeQueue.add(new Node(start, 0));

    while(!nodeQueue.isEmpty()) {

      Node here = nodeQueue.poll();
      List<Integer> connections = node[here.number];
      int cDistance = here.distance;

      boolean isMove = false;

      for(int next : connections) {
        if(visited[next]) continue;
        visited[next] = true;
        isMove = true;
        nodeQueue.add(new Node(next, cDistance + 1));
      }

      if(!isMove) {
        if(cDistance == distance) {
          answer++;
        }
        else if(cDistance > distance) {
          distance = cDistance;
          answer = 1;
        }
      }
    }

  }
  private class Node {
    int number;
    int distance;

    Node(int number, int distance) {
      this.number = number;
      this.distance = distance;
    }
  }

}

```

### ğŸ“–Â í•´ê²°ë°©ë²•

`BFS`

1. ê° ë…¸ë“œë§ˆë‹¤ ì—°ê²°ëœ ë…¸ë“œì— ëŒ€í•œ Listë¥¼ ìƒì„±
2. BFSë¥¼ ëŒë©´ì„œ ê° ë…¸ë“œì—ì„œ ì—°ê²°ëœ ë…¸ë“œë¡œ ì´ë™
3. ë”ì´ìƒ ê°ˆ ê³³ì´ ì—†ëŠ” ê²½ìš° í˜„ì¬ ê°€ì¥ ë¨¼ ë…¸ë“œê¹Œì§€ì˜ ê±°ë¦¬ì™€ í˜„ì¬ ë…¸ë“œê¹Œì§€ì˜ ê±°ë¦¬ë¥¼ ë¹„êµí•˜ì—¬ ê°’ ê°±ì‹ 
